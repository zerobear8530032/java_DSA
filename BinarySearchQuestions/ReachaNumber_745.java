//754. Reach a Number
//Solved
//Medium
//Topics
//Companies
//You are standing at position 0 on an infinite number line. There is a destination at position target.
//
//You can make some number of moves numMoves so that:
//
//On each move, you can either go left or right.
//During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.
//Given the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.
//
// 
//
//Example 1:
//
//Input: target = 2
//Output: 3
//Explanation:
//On the 1st move, we step from 0 to 1 (1 step).
//On the 2nd move, we step from 1 to -1 (2 steps).
//On the 3rd move, we step from -1 to 2 (3 steps).
//Example 2:
//
//Input: target = 3
//Output: 2
//Explanation:
//On the 1st move, we step from 0 to 1 (1 step).
//On the 2nd move, we step from 1 to 3 (2 steps).
// 
//
//Constraints:
//
//-109 <= target <= 109
//target != 0
package BinarySearchQuestions;


public class ReachaNumber_745 {
	
	// https://youtu.be/kz_0GjhFOzc?si=4ya4kyDNc20fKpGp:
    // check video to understand the solution
//	O(n) where n = number of moves 
        public static int reachNumberBruteForce(int target) {
        int sum =0;
        if(target<0){
        target =target*-1;
        }
        for(int move =1;true;move++){
            if(target>sum){
                sum=sum+move;
            }else{
                if((sum-target)%2==0){
                    return move-1;
                }else{
                    sum=sum+move;
                }
            }
        }
    }
//        idk how it work generated by chat gpt:
//	time complexity : O(log n) where n = number of moves 
            public static int reachNumberOptimize(int target) {
                // Take absolute value of target for simplicity
                target = Math.abs(target);
                
                // Binary search initialization
                int left = 1;
                int right = (int) Math.sqrt(2 * target) + 1;
                
                while (left < right) {
                    int mid = left + (right - left) / 2;
                    int sum = mid * (mid + 1) / 2;
                    
                    if (sum < target) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                
                // After binary search, 'left' will be the minimum k such that sum >= target
                int sum = left * (left + 1) / 2;
                
                // If difference is even, return 'left'
                // If difference is odd, we need to add one more step to make the difference even
                if ((sum - target) % 2 == 0) {
                    return left;
                } else {
                    return left + (left % 2 == 0 ? 1 : 2);
                }
            }
        

	
//Example 1:
//
	public static void main(String[] args) {
		
	int target1 = 2;
	int output1= 3;
//Explanation:
//On the 1st move, we step from 0 to 1 (1 step).
//On the 2nd move, we step from 1 to -1 (2 steps).
//On the 3rd move, we step from -1 to 2 (3 steps).
	if(output1==reachNumberBruteForce(target1)) {
		System.out.println("Case 1 passed");
	}else {
		System.out.println("Case 1 Failed");		
	}
	
	//Example 2:
//
	int target2 = 3;
	int output2= 2;

	if(output2==reachNumberBruteForce(target2)) {
		System.out.println("Case 2 passed");
	}else {
		System.out.println("Case 2 Failed");		
	}
//	optimize
	if(output1==reachNumberOptimize(target1)) {
		System.out.println("Case 1 passed");
	}else {
		System.out.println("Case 1 Failed");		
	}
	if(output2==reachNumberOptimize(target2)) {
		System.out.println("Case 2 passed");
	}else {
		System.out.println("Case 2 Failed");		
	}
	
//Explanation:
//On the 1st move, we step from 0 to 1 (1 step).
//On the 2nd move, we step from 1 to 3 (2 steps).

	int target3 = 4;
	int output3= 3;
	
	}
	

}
